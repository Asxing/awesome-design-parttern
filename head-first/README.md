让自己的大脑就范：

- 慢一点，你理解的越多，需要记的笔记就越少。
- 勤做练习，自己记笔记。
- 注意要仔细阅读备注。
- 上传之前不要看其他的有难度的书。
- 要喝水，而却要多喝水。
- 大声说出来。
- 听听你的大脑怎么说。
- 要有点感觉。
- 自己设计一些东西。



# 第一章 设计模式入门

## 基本概念

基础：

- 抽象
- 封装
- 多态
- 继承



设计原则：

- 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。
- 我们要针对接口编程，而不是针对实现编程。
- 多用组合，少用继承。



## 策略模式

> 定义算法族，分别封装起来，让他们之前可以相互替换，此模式让算法的变化独立于使用算法的客户。

> **真正的策略模式核心即：封装行为，依赖接口，组合代替继承**

`有一个`比`是一个`更好。

# 第二章 观察者模式

- 观察者模式是 JDK 中使用最多的模式之一。
- 生活中常见的观察者模式：出版者 + 订阅者 = 观察者模式
- 观察者模式中两个概念：
  - 主题：主题对象管理某些数据。
  - 观察者：也就是我们所说的订阅者，订阅主题以便在主题数据发生改变时能够收到更新。
- 观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
- 定义观察者模式类图

![image-20200517193241310](https://www.holddie.com/img/20200517193248.png)

- 关于观察者的一切，主题只知道观察者实现了某个接口（也就是 Observer 接口）。主题不需要知道观察者的具体类是谁、做了哪些什么或者其他任何细节。
- 任何时候我们都可以增加新的观察者。因为主题唯一一来的东西是一个实现 Observer 接口的对象列表，我们可以随时增加和移除观察者。
- 改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间接口仍被遵守，我们就可以自由改变他们。
- 对于订阅主题的观察者来说，有两种方式接收数据，一种是通过主题直接推送给观察者，一种是观察者主动去获取数据。
- Java 内置的观察者模式
  - java.util 包内包含类最基本的 Observer 接口和 Observable 类，分别对应我们熟悉的观察者和主题。
  - Java 内置的观察者模式支持推（Push）或拉（Pull）两种方式传输数据。
  - 利用 Observable 接口产生“观察者”，然后需要两个步骤
    - 首先调用 setChanged() 方法，标记状态已经改变的事实。
    - 然后调用 notifyObservers()方法中的一个
      - notifyObservers() 或者 notifyObservers(Object arg)
  - 如果你想“推”数据给观察者，你可以把数据对象传送给 notifyObservers(arg) 方法，否则，观察者必须采用“拉”数据。
  - setChanged() 方法可以满足灵活调用 notifyObservers() 方法。
  - 不足
    - java.uitl.Observable 实现了它的 notifyObservers() 方法，这可能导致通知观察者的次序不同于我们先前的次序。
    - 因为 Observeable 是这个类，如果想同时继承具有 Observeable 和 另一个超类的行为，就会陷入两难，这样限制了 Observable 的复用性。
    - Observable 将关键的方法保护起来，例如 setChanged() 方法被保护，违反了“多用组合，少用继承”的原则。

# 第三章 装饰者模式

- 设计原则：类应该对扩展开放，对修改关闭。
- 装饰者和被装饰者对象都有相同的超类型。
- 你可以用一个或多个装饰者包装一个对象。
- 既然装饰者和被装饰者对象有相同的超类型，所以在任何需要院士对象（被包装的）的场合，可以用装饰过的对象代替它。
- 装饰者可以再所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。
- 对象可以再任何时候被装饰，所以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。
- 装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
- 在装饰者模式中，继承一个抽象类，是为了有正确的类型，而不是继承它的行为。行为来自装饰者和基础组件，或与其他装饰者之间的组合关系。
- Java 语言中的装饰者（Java I/O）
  - FileInputStream 是被装饰的“组件”。Java I/O 程序库提供了几个组件，包括了 FileInputStream、StringBufferInpustStream、ByteArrayInputStream...等。这些类都是提供了最基本的字节读取功能 。
  - BufferedInpustStream 是一个具体的装饰者，他加入两种行为：利用缓冲输入来改进性能；用一个 readLine() 方法（用来一次读取一行文本输入数据）来增强接口。
  - LineNumberInputStream 也是一个具体的“装饰者‘。他加上了计算行数的能力。
  - ![image-20200517223354950](https://www.holddie.com/img/20200517223356.png)



# 第四章 工厂模式

- 对于经常使用“new” 来生成对象的，一旦有变化或者扩展，就必须重新打开这段代码进行检查和修改，通过这样修改过的代码将造成部分系统更难维护和更新，而且也更容易犯错误。
- 使用工厂方法屏蔽创建对象的细节，最初我们可以想到的就是使用 `if` 进行区分。
- 简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。
- 工厂方法用来处理对象的创建，并将这样的行为封装在子类中，这样，客户程序中关于超类的代码和子类对象创建代码解耦了。
- 工厂方法是抽象的，所以依赖子类来处理对象的创建。
- 工厂方法必须返回一个产品，超类中定义的方法，通常使用到工厂方法的返回值。
- 工厂方法将客户和实际创建具体产品的代码分割开来。
- 工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
- 如何避免在面向对象设计中违反依赖倒置原则
  - 变量不可以持有具体类的引用，如果使用 new 关键字，就会持有具体类的引用，你可以改用工厂来避开这样的做法。
  - 不要让类派生子具体类，如果派生自具体类，你聚会依赖具体类，请派生自一个抽象。
  - 不要覆盖基类中已实现的方法，如果覆盖基类中已经实现的方法，那么你的基类就不是一个真正适合被继承的抽象，基类中已实现的方法，应该由所有的子类共享。



# 第五章 单例模式

- 单例模式：确保一个类只有一个实例，并提供一个全局访问点。
- 处理多线程：
  - 可以使用同步方法实现
  - 懒汉模式和饱汉模式

# 第六章 命令模式

命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

## 命令模式的多用途

### 队列请求

命令可以将运算块打包然后将它传来传去，就像是一般的抓了一样，现在即使在命令对象被创建许久之后，运算依然可以被调用。

常用的衍生应用：日志安排、线程池、工作牌队列。

想象有一个工作队列，你再某一个端添加命令，然后另一端再试现成。线程进行下面操作：从队列中取出一个命令，调用它的 execute() 方法，等等这个调用完成，然后将此命令对象丢弃，再取出下一个命令。



在某些应用中我们需要将所有的动作都记录在日志中，并能在系统死机之后，重新调用这些动作恢复到之前的状态，通过新增两个方法（store()、load()），命令模式就支持这一点。



命令模式要点：

- 命令模式将发出请求的对象和执行请求的对象解耦
- 在被解耦的两者之间通过命令对象进行沟通，命令对象封装了接受者和一个或一组动作。
- 调用者通过调用命令对象的 execute() 发出请求，这会使得接收者的动作被调用。
- 调用者可以接受命令当做参数，甚至在运行时动态地进行。
- 命令可以支持撤销，做法是实现一个 undo() 方法来回到 execute() 被执行钱的状态。
- 命令也可以用来实现日志和事务系统。



# 第七章 适配器模式与外观模式

- 客户通过目标接口调用适配器的方法对适配器发出请求。

- 适配器使用被适配者接口把请求转换成被适配者的一个或者多个调用接口。
- 客户接受到调用的结果，但并未察觉这一切是适配器在起转换作用。



适配器模式：将一个类的接口，转换成酷虎期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。



适配器模式充满着良好的 OO 设计原则：使用对象组合，已修改的接口包装被适配者，这种做法还有额外的优点，那就是被适配者的任何子类都可以搭配着适配器使用。

对于适配器模式实际使用中可以有两种含义的适配：一种是“对象”适配器，一种是“类”适配器。



针对于类的适配，主要实现方式是通过多重继承，需要明确的一点是 Java 不支持多重继承。



外观接口：提供了一个统一的接口，用来防蚊子系统的一群接口，外观定义了一个高层接口，让子系统更容易使用。



其中符合“最少知识”原则：减少对象之间的依赖和交互。